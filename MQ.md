# 消息队列使用场景

- 异步处理
- 流量控制
- 系统解耦
- 发布/订阅
- 连接流计算任务、数据
- 消息广播

> 单体应用中可以使用队列解决的问题，在分布式系统中的解决方案可以是 MQ

## 1.异步处理

比如如何短时间内处理海量请求，以秒杀系统为例，秒杀假设需要五个步骤：

- 风险控制
- 库存锁定
- 生成订单
- 短信通知
- 更新统计数据

我们可以这么做：当前两步完成后，其实秒杀就成功了，后续的三步的操作信息放入消息队列中，再由各个模块进行消费异步处理。

这样可以短时间内处理更多的请求，减少了等待，并发性能增强

## 2. 流量控制

使用消息队列进行流量控制，保证后端服务在大量请求下仍然能够按照自己的最大能力范围进行服务，避免垮掉。

使用消息队列隔离网关与后端服务，达到流量控制与保护后端服务。

常用以下两种方式：

1. 请求 -> (网关 -> 将请求放入 MQ ）-> 后端服务消费 MQ，完成请求处理

后端根据自己能力范围消费 MQ，对于超时的请求，网关层直接返回处理失败

- 上下游将同步变成了异步，系统复杂度增加
- 调用链变长，响应时间增加

2. 请求 -> 网关申请令牌 -> 获得令牌，调用后端处理，否则返回失败

需要一个令牌生成器按照相应速度产生令牌，令牌存储在 MQ 中，网关每收到一个请求去 MQ 中消费一个令牌

## 服务解耦

比如订单服务与其下游服务，增加消息队列存储订单数据，下游服务可以直接订阅 MQ 消费 order，订单服务生产 order，实现解耦。

# 带来的问题

- 延迟问题
- 系统复杂度增加
- 可能产生数据不一致

# 如何选择消息队列

- 消息不丢失
- 是否具有集群特性
- 开源社区是否活跃

# 基础概念 - 消息模型

两种常用模型：

- 队列模型
- 发布/订阅模型

传统的队列模型就是先进先出，删除对应出队，添加对应入队。当有多个消费者消费同一个队列的时候，往往只能消费到部分消息。

发布/订阅模型：

- 发布者：消息发送者
- 订阅者：消息接收者
- 主题：服务端存放消息的容器

每一份订阅中，订阅者都可以接收到主题的所有消息

> 1. 两种模型的最大区别就是一份消息能否被多次消费
> 2. 现代的 MQ 大多使用发布订阅模型

几乎所有的 MQ 都使用**请求 - 确认**机制，保证消息在传递的过程中不会由于网络故障或服务器故障丢失
（类似 TCP 中的机制）
1. 生产者发生消息到 server，需要等待 server 操作完后发送的消息，否则超时或者失败可能重发
2. 消费者消费消息完后，发送操作完成消息给 server，若 server 收不到，会重新发送消息给其处理

## RabbitMQ 消息模型

基于的是传统的队列模型，但是可以通过 Exchange 模块配置策略实现发布订阅功能

生产者 -> Exchange -> 队列1、队列2..... <- 消费者1 消费 队列1...

生产者不管投放的是哪个队列，只管投放到 Exchange

## RocketMQ 消息模型

标准的发布订阅模型，拥有：**生产者、消费者、主题**

特殊：**队列**，为的是解决消息空洞问题或者说是有序性的违背（每个主题在任意时刻只能有一个消费者实例进行消费，否则无法通过水平扩展消费者数量提升总体性能）

**队列或者分区会被一个消费组中的消费实例占据**

**每个主题包括多个队列，通过多个队列来实现多实例并行生产和消费**

RocketMQ 只在队列上保证消息的有序性，主题层面上无法保证消息的严格顺序

![6c32f7ae.png](:storage\76528c58-9404-4b18-a3a1-c340e1a435da\6c32f7ae.png)

由于消息需要被不同的组进行多次消费，所以消息不会被立即删除，每个消费组在每个队列上维护一个消费位置

## Kafka 消息模型

与 RocketMQ 类似，名称有所区别，对应的队列叫做**分区**

# 基础概念 - MQ 中的事务

解决的是消息生产者与消息消费者的数据一致性问题

在分布式系统中严格实现事务的 ACID 是非常困难的，大多是不完整的实现，比较常见的有：

- 2PC
- TCC
- 事务消息

事务消息适合的场景：异步更新数据，对数据实时性要求不太高的场景

RocketMQ 事务提供了反查机制，补偿提交事务消息可能出现的通信失败

kafka 中提交失败则直接抛出异常，自行处理异常

# 消息可靠性的保证，不丢消息

生产者和消费者基本采用的是**请求确认机制**

![adf39fd0.png](:storage\8c1e229f-a6e8-48ce-b315-3acd5056afd6\adf39fd0.png)

1. 生产者发送消息给存储端，并收到存储端的消息确认才算发送完成，未收到会进行重发

代码中需要捕获发送的异常或者结果

2. 消费者拉取消息后，进行处理，并向存储端返回一个响应，如果存储端收不到响应则该消息并未被记录为消费，下次拉取消息的时候仍然会返回该消息

代码中消费消息的时候，应该等业务操作完成后，在返回确认消费的消息

3. 在存储端可以通过配置 Broker 参数避免宕机丢消息

- 单个节点，可以配置参数收到消息后，写入磁盘后再给生产者返回确认响应
- 集群模式，则至少需要将消息发送给2个以上的节点，再给客户端回复发送确认响应

**如何确认消息丢失？**

可以利用消息的有序性，在 producer 端，每发出一个消息附加一个连续递增的序号

在 consumer 端检查这个序号的连续性

目前，大多数的消息队列 client 都支持**拦截器机制**，可以利用拦截器在 producer 发送消息的时候注入序号

在 consumer 收到消息的拦截器中检测序号的连续性，这样可以减少对业务代码的浸入

在分布式系统中，由于只能保证分区或者队列的消息是有序的，那么在发送消息的时候就需要指定分区，在每个分区单独检测消息序号的连续性

**解决消息重复的问题**

一般使用的是在消费端保证消息操作具备**幂等性**

> 幂等性：任意多次执行所产生的影响与一次执行的影响相同

常用实现方式：

- 使用数据库等约束条件，比如唯一索引
- 设置前置条件，可以对数据增加一个版本号，在消息队列中的消息增加一个版本号，处理消息的时候版本号不一致，拒绝处理
- 设置全局 ID，分布式 ID 生成器或者分布式锁（实现难度较为复杂）

**消息积压处理**

根本原因：消息发送者与接收者的各自的收发速率不一致

解决方法：

- 批量处理
- 并发
- 水平扩容

对消费者实例进行水平扩容需要同时对分区进行扩容，因为分区是会被某一消费者占据，不扩容是起不到效果的








